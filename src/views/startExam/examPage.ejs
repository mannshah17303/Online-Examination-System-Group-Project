<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Exam Page</title>
  <link rel="stylesheet" href="/css/examPage/examPage.css" />
</head>

<body>
  <canvas id="canvas" width="640" height="480" style="display: none"></canvas>
  <video id="videoTag" autoplay hidden></video>
  <video id="webCam" autoplay style="display: none"></video>
  <div class="startBtnDiv" id="startBtnDiv">
    <Button id="startBtn">Start Exam</Button>
  </div>

  <div id="questionAnswerDiv" class="hideDiv">
    <div id="timer">timer</div>
    <div id="question"></div>
    <div id="answerOptions"></div>

    <div id="prevNextBtnDiv">
      <button type="button" id="prevBtn">
        << Prev</button>
          <button type="button" id="nextBtn">Next >></button>
          <button type="button" id="submitBtn">Submit</button>
    </div>
  </div>

  <div id="attendedQuestionsBoxesDiv" class="hideDiv">
    <div id="boxes"></div>
    <div id="attendedQuestionsInfo">
      <div>total questions : <span id="totalQuestions"></span></div>
      <div>Attended questions : <span id="attendedQuestions">0</span></div>
    </div>
  </div>

  <!-- <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
  <script src="/socket.io/socket.io.js"></script>
  <script>
    let questions = [];
    let counter = 0;
    let qId = 0;
    let arr;
    let recordedChunks = [];
    const videoTag = document.getElementById("videoTag");
    let recordingOngoing = false;
    let mediaRecorder;
    let webCamStream;
    const webCam = document.getElementById("webCam");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    let multipleCandidateCount = 0;

    let model;
    window.onload = async () => {
      // model = await cocoSsd.load();
      model = await cocoSsd.load({ base: "mobilenet_v2" });
    };

    let totalPersonCount = 0;
    let totalCellPhoneCount = 0;
    let warningAlertShown = false;
    async function cocossd(webCam, ctx, width, height) {
      try {
        // console.log("totalPersonCount: ", totalPersonCount);
        if (
          totalPersonCount > 5 &&
          totalPersonCount <= 10 &&
          !warningAlertShown
        ) {
          alert(
            "there are so many people around you please remove the surrounding people otherwise exam will be over"
          );
          warningAlertShown = true;
        } else if (totalPersonCount > 10) {
          await exitExam();
        } else if (totalCellPhoneCount > 4) {
          await exitExam();
        } -->

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <!-- <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface"></script> -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script>
      let questions = [];
      let counter = 0;
      let qId = 0;
      let arr;
      let recordedChunks = [];
      const videoTag = document.getElementById("videoTag");
      let recordingOngoing = false;
      let mediaRecorder;
      let webCamStream;
      const webCam = document.getElementById("webCam");
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      let multipleCandidateCount = 0;

      let model;
      window.onload = async () => {
        // model = await cocoSsd.load();
        model = await cocoSsd.load({ base: "mobilenet_v2" });
      };

      let totalPersonCount = 0;
      let totalCellPhoneCount = 0;
      let warningAlertShown = false;
      async function cocossd(webCam, ctx, width, height) {
        try {
          // console.log("totalPersonCount: ", totalPersonCount);
          if (
            totalPersonCount > 5 &&
            totalPersonCount <= 10 &&
            !warningAlertShown
          ) {
            alert(
              "there are so many people around you please remove the surrounding people otherwise exam will be over"
            );
            warningAlertShown = true;

            if (!document.fullscreenElement) {
              if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen();
                navigator.keyboard.lock();
              } else if (document.documentElement.msRequestFullscreen) {
                document.documentElement.msRequestFullscreen();
                navigator.keyboard.lock();
              } else if (document.documentElement.mozRequestFullScreen) {
                document.documentElement.mozRequestFullScreen();
                navigator.keyboard.lock();
              } else if (document.documentElement.webkitRequestFullScreen) {
                document.documentElement.webkitRequestFullScreen();
                navigator.keyboard.lock();
              }
            }

            document.addEventListener("fullscreenchange", () => {
              if (!document.fullscreenElement) {
                fullScreenOffCount++;
                console.log("fullScreenOffCount: ", fullScreenOffCount);
                if (browserTabChangeCount > 0) {
                  exitExam();
                }

                window.onblur = (e) => {
                  exitExam();
                };

                interval = setInterval(() => {
                  if (oldX != window.screenX || oldY != window.screenY) {
                    // console.log("Window screen size changes!");

                    exitExam();
                  }

                  oldX = window.screenX;
                  oldY = window.screenY;
                }, 500);
              } else if (document.fullscreenElement) {
                document.addEventListener("pointerdown", (e) => {
                  lastPointerClick = true;
                });

                interval = setInterval(() => {
                  if (oldX == window.screenX || oldY == window.screenY) {
                    return;
                  }

                  oldX = window.screenX;
                  oldY = window.screenY;
                }, 500);
              } else {
                clearInterval(interval);
              }
            });
          } else if (totalPersonCount > 10) {
            await exitExam();
          } else if (totalCellPhoneCount > 4) {
            await exitExam();
          }

          const result = await model.detect(webCam);
          // console.log("result: ", result);
          let personCount = 0;
          let cellPhoneCount = 0;

        ctx.drawImage(webCam, 0, 0, width, height);
        ctx.font = "20px Arial";

        if (result.length > 0) {
          if (result.length > 1) {
            // console.log("personCount: ", personCount);
            // console.log("cellPhoneCount: ", cellPhoneCount);

            result.forEach((r) => {
              if (r.class == "person") personCount++;
              else if (r.class == "cell phone") cellPhoneCount++;
            });

            if (personCount > 1) {
              // console.log("personCount: ", personCount);
              totalPersonCount++;
            } else if (cellPhoneCount > 0) {
              // console.log(
              //   "cellPhoneCount greater than zero: ",
              //   cellPhoneCount
              // );
              totalCellPhoneCount++;
            }
            // console.log("personCount: ", personCount);
            // console.log("cellPhoneCount: ", cellPhoneCount);
          }

          for (let i = 0; i < result.length; i++) {
            ctx.beginPath();
            ctx.rect(...result[i].bbox);
            ctx.lineWidth = 3;
            ctx.strokeStyle = "yellow";
            ctx.fillStyle = "blue";
            ctx.stroke();
            ctx.fillText(
              result[i].score.toFixed(3) + " " + result[i].class,
              result[i].bbox[0],
              result[i].bbox[1] > 10 ? result[i].bbox[1] - 5 : 10
            );
          }
        } else {
          console.log("No object detected!");
        }

        personCount = 0;
        cellPhoneCount = 0;
        if (totalPersonCount <= 5) {
          warningAlertShown = false;
        }
      } catch (error) {
        throw new Error(error);
      }
    }

    // async function draw(webCam, ctx, width, height) {
    //   try {
    //     if (multipleCandidateCount > 15) {
    //       await exitExam();
    //     }
    //     ctx.drawImage(webCam, 0, 0, width, height);
    //     const model = await blazeface.load();
    //     const predictions = await model.estimateFaces(webCam, false);

    //     if (predictions.length > 0) {
    //       if (predictions.length > 1) {
    //         console.log("more than one person detected!");
    //         multipleCandidateCount++;
    //       }
    //       console.log(predictions);
    //       for (let i = 0; i < predictions.length; i++) {
    //         const start = predictions[i].topLeft;
    //         const end = predictions[i].bottomRight;
    //         var probability = predictions[i].probability;
    //         const size = [end[0] - start[0], end[1] - start[1]];
    //         ctx.beginPath();
    //         ctx.lineWidth = "5";
    //         ctx.strokeStyle = "blue";
    //         ctx.rect(start[0], start[1], size[0], size[1]);

    //         // const landmarks = predictions[i].landmarks;
    //         // const right_eye = landmarks[0];
    //         // ctx.fillRect(right_eye[0], right_eye[1], 8, 8);
    //         // const left_eye = landmarks[1];
    //         // ctx.fillRect(left_eye[0], left_eye[1], 8, 8);
    //         // const nose = landmarks[2];
    //         // ctx.fillRect(nose[0], nose[1], 8, 8);
    //         // const mouth = landmarks[3];
    //         // ctx.fillRect(mouth[0], mouth[1], 8, 8);
    //         // const right_ear = landmarks[4];
    //         // ctx.fillRect(right_ear[0], right_ear[1], 8, 8);
    //         // const left_ear = landmarks[5];
    //         // ctx.fillRect(left_ear[0], left_ear[1], 8, 8);
    //         ctx.stroke();
    //       }
    //     }
    //   } catch (error) {
    //     throw new Error(error);
    //   }
    // }

    // const detectFaces = async () => {
    //   try {
    //     ctx.drawImage(webCam, 0, 0, 300, 300);
    //     const model = await blazeface.load();

    //     const predictions = await model.estimateFaces(webCam, false);
    //     console.log("prediction: ", predictions);

    //     if (predictions.length > 0) {
    //       for (let i = 0; i < predictions.length; i++) {
    //         const start = predictions[i].topLeft;
    //         const end = predictions[i].bottomRight;
    //         var probability = predictions[i].probability;
    //         const size = [end[0] - start[0], end[1] - start[1]];
    //         ctx.beginPath();
    //         ctx.lineWidth = "5";
    //         ctx.strokeStyle = "blue";
    //         ctx.rect(start[0], start[1], size[0], size[1]);

    //         const landmarks = predictions[i].landmarks;
    //         const right_eye = landmarks[0];
    //         ctx.fillRect(right_eye[0], right_eye[1], 8, 8);
    //         const left_eye = landmarks[1];
    //         ctx.fillRect(left_eye[0], left_eye[1], 8, 8);
    //         const nose = landmarks[2];
    //         ctx.fillRect(nose[0], nose[1], 8, 8);
    //         const mouth = landmarks[3];
    //         ctx.fillRect(mouth[0], mouth[1], 8, 8);
    //         const right_ear = landmarks[4];
    //         ctx.fillRect(right_ear[0], right_ear[1], 8, 8);
    //         const left_ear = landmarks[5];
    //         ctx.fillRect(left_ear[0], left_ear[1], 8, 8);
    //         ctx.stroke();
    //       }

    //       // prediction.forEach((p) => {
    //       //   console.log("pred: ", p);
    //       //   if (returnTensors) {
    //       //     p.topLeft = p.topLeft.arraySync();
    //       //     p.bottomRight = p.bottomRight.arraySync();
    //       //     if (annotateBoxes) {
    //       //       p.landmarks = p.landmarks.arraySync();
    //       //     }
    //       //   }

    //       //   ctx.beginPath();
    //       //   ctx.lineWidth = "5";
    //       //   ctx.strokeStyle = "blue";
    //       //   // ctx.fillStyle = "rgba(255, 0, 0, 0.5)";

    //       //   ctx.rect(
    //       //     p.topLeft[0],
    //       //     p.topLeft[1],
    //       //     p.bottomRight[0] - p.topLeft[0],
    //       //     p.bottomRight[1] - p.topLeft[1]
    //       //   );
    //       //   // ctx.stroke();

    //       //   // ctx.fillStyle = "blue";
    //       //   // p.landmarks.forEach((l) => {
    //       //   //   ctx.fillRect(l[0], l[1], 5, 5);
    //       //   // });
    //       // });
    //     } else {
    //       console.log("No faces found!");
    //     }
    //   } catch (error) {
    //     console.log(error);
    //     throw new Error(error);
    //   }
    // };

    async function getConnectedDevices(type) {
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();

        if (devices) {
          const filteredDevice = devices.filter(
            (device) => device.kind == type
          );
          return filteredDevice;
        }
      } catch (error) {
        // console.log(error);
        throw new Error(error);
      }
    }

    const socket = io();
    function startWebSocketStreaming(stream) {
      // console.log("srcObject: ", videoTag.srcObject);

      let examId = "<%= examId %>";
      let studentId = "<%= studentId %>";
      const canvas1 = document.createElement("canvas");
      const ctx1 = canvas1.getContext("2d");

      videoTag.onloadedmetadata = () => {
        canvas1.width = videoTag.videoWidth;
        canvas1.height = videoTag.videoHeight;

        setInterval(() => {
          ctx1.drawImage(videoTag, 0, 0, canvas1.width, canvas1.height);
          const imageData = canvas1.toDataURL("image/webp", 0.5);

          socket.emit("screen-data", {
            examId: "<%= examId %>",
            studentId: "<%= studentId %>",
            imageData: imageData,
          });
        }, 300);
      };
    }

    async function startScreenRecording() {
      try {
        const videoDevice = await getConnectedDevices("videoinput");
        const audioDevice = await getConnectedDevices("audioinput");
        // console.log("videoDevice: ", videoDevice);
        // console.log("audioDevice: ", audioDevice);

        if (videoDevice.length > 0 && audioDevice.length > 0) {
          // console.log("inside first if case");

          let stream = await navigator.mediaDevices.getDisplayMedia({
            video: {
              displaySurface: "monitor",
              width: 1280,
              height: 720,
              frameRate: 30,
            },
            audio: false,
          });

          webCamStream = await navigator.mediaDevices.getUserMedia({
            video: true,
            audio: false,
          });

          if (
            stream.getVideoTracks()[0].getSettings().displaySurface !==
            "monitor"
          ) {
            // console.log("inside full screen checkout!");

            let tracks = stream.getTracks();
            tracks.forEach((track) => track.stop());
            stream = null;

            let webCamTracks = webCamStream.getTracks();
            webCamTracks.forEach((webCamTrack) => webCamTrack.stop());
            webCamStream = null;

            alert("Selection of entire screen is compulsory!");
            return [stream, webCamStream];
          } else {
            videoTag.srcObject = stream;
            webCam.srcObject = webCamStream;

            startWebSocketStreaming(stream);

            // webCam.play();
            mediaRecorder = new MediaRecorder(stream);

            webCam.addEventListener(
              "play",
              function () {
                setInterval(cocossd, 2000, webCam, ctx, 640, 480);
              },
              false
            );

            // webCam.addEventListener(
            //   "play",
            //   function () {
            //     setInterval(draw, 100, webCam, ctx, 640, 480);
            //   },
            //   false
            // );

            // ctx = canvas.getContext("2d");
            // ctx.fillStyle = "rgba(255, 0, 0, 0.5)";
            // webCam.addEventListener(
            //   "play",
            //   async () => {
            //     // model = await blazeface.load();
            //     setInterval(detectFaces, 100);
            //   },
            //   false
            // );

            // mediaRecorder.ondataavailable = (e) => {
            //   if (e.data.size > 0) {
            //     recordedChunks.push(e.data);
            //   }
            // };

            // mediaRecorder.onstop = () => {
            //   recordedChunks = [];
            //   const blob = new Blob(recordedChunks, { type: "video/webm" });
            //   const videoURL = URL.createObjectURL(blob);
            //   const a = document.createElement("a");
            //   a.href = URL.createObjectURL(videoURL);
            //   a.download = `exam-screen-recording-${Date.now()}.webm`;
            //   a.click();
            // };

            mediaRecorder.onstart = () => {
              if (document.fullScreenElement) {
                document.exitFullscreen();
              } else {
                // document.documentElement.requestFullscreen();
                if (document.documentElement.requestFullscreen) {
                  document.documentElement.requestFullscreen();
                  navigator.keyboard.lock();
                } else if (document.documentElement.msRequestFullscreen) {
                  document.documentElement.msRequestFullscreen();
                  navigator.keyboard.lock();
                } else if (document.documentElement.mozRequestFullScreen) {
                  document.documentElement.mozRequestFullScreen();
                  navigator.keyboard.lock();
                } else if (document.documentElement.webkitRequestFullScreen) {
                  document.documentElement.webkitRequestFullScreen();
                  navigator.keyboard.lock();
                }
              }
            };

            stream.addEventListener("inactive", (e) => {
              exitExam();
            });

            mediaRecorder.start();

            return [stream, webCamStream];
          }
        } else {
          alert("video and audio capturing devices are mandatory!");
        }
      } catch (error) {
        // console.log("error: ", error);

        if (error.name == "NotAllowedError") {
          return;
        } else if (error.name == "NotFoundError") {
          alert("Selection of entire screen is compulsory!");
          return;
        }

        // console.log(error);
        throw new Error(error);
      }
    }

    async function stopScreenRecording() {
      try {
        webCamStream.getTracks().forEach((track) => track.stop());
        mediaRecorder.stop();

        mediaRecorder.ondataavailable = (e) => {
          // const a = document.createElement("a");
          // a.href = URL.createObjectURL(e.data);
          // console.log(a.href);
          // a.download = `exam-screen-recording-${Date.now()}.webm`;
          //  a.click();

          if (e.data.size > 0) recordedChunks.push(e.data);
        };

        mediaRecorder.onstop = async () => {
          const examId = "<%= examId %>";
          const blob = new Blob(recordedChunks, { type: "video/webm" });
          const formData = new FormData();
          formData.append("examId", examId);
          formData.append("recording", blob, "screen.webm");

          const response = await fetch(
            "/api/start-exam/upload-screen-recording",
            {
              method: "POST",
              body: formData,
            }
          );

          const data = await response.json();
          // console.log("url: ", data.url);
        };
      } catch (error) {
        // console.log(error);
        throw new Error(error);
      }
    }

    let examDuration;

    async function examSidebarDetails() {
      try {
        let examId = "<%= examId %>";
        let result = await fetch("/api/start-exam/exam-sidebar-details", {
          method: "post",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ examId: examId }),
        });

        let response = await result.json();
        // console.log("examDetails: ", response);

        examDuration = response.data.examDetails[0].duration;

        document.getElementById("examName").innerHTML =
          response.data.examDetails[0].exam_name;

        document.getElementById("examDescription").innerHTML =
          response.data.examDetails[0].exam_description;

        document.getElementById("examDuration").innerHTML =
          response.data.examDetails[0].duration;

        document.getElementById("examTotalMarks").innerHTML =
          response.data.examDetails[0].total_marks;

        document.getElementById("examPassingMarks").innerHTML =
          response.data.examDetails[0].passing_marks;

        document.getElementById("examCreatedBy").innerHTML =
          response.data.adminName[0].first_name +
          " " +
          response.data.adminName[0].last_name;
      } catch (err) {
        // console.log("error in examSidebarDetails");
        console.log(err);
      }
    }

    async function getQuestions() {
      try {
        let examId = "<%= examId %>";
        let result = await fetch("/api/start-exam/get-questions", {
          method: "post",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ examId: examId }),
        });

        let response = await result.json();
        console.log("response: ", response);
        return response.data;
      } catch (err) {
        // console.log("error in getQuestions");
        console.log(err);
      }
    }

    function showQuestionAndOptions(index) {
      // console.log("questions: ", questions);

      document.getElementById("question").innerHTML =
        questions[index]["questionText"] +
        "      " +
        questions[index]["questionMarks"];

      if (questions[index]["questionType"] == "Subjective") {
        document.getElementById(
          "answerOptions"
        ).innerHTML = `<input type="text" name="studentAns" id="studentAns">`;

        // Also modify the subjective answer handler to use the same approach
        // This would go in your showQuestionAndOptions function
        document
          .getElementById("studentAns")
          .addEventListener("change", () => {
            if (document.getElementById("studentAns").value.trim() === "") {
              document
                .getElementById(counter + 1)
                .classList.remove("filled-square");
              arr[counter] = "";
            } else {
              document
                .getElementById(counter + 1)
                .classList.add("filled-square");
              arr[counter] = document.getElementById("studentAns").value;
            }
            updateAttendedQuestionsCount();
          });
        //   return index;
      } else {
        let htmlStr = ``;

        for (let i = 0; i < questions[index]["options"].length; i++) {
          htmlStr += `<div><input type="radio" id="${questions[index]["options"][i]["optionText"]}" value="${questions[index]["options"][i]["optionText"]}" name="answerOption">
                <label for="a">${questions[index]["options"][i]["optionText"]}</label></div>`;
        }

        document.getElementById("answerOptions").innerHTML = htmlStr;

        //   return index;
      }
    }

    function checkForDisablingButton() {
      if (counter == questions.length - 1) {
        document.getElementById("nextBtn").disabled = true;
      } else {
        document.getElementById("nextBtn").disabled = false;
      }

      if (counter == 0) {
        document.getElementById("prevBtn").disabled = true;
      } else {
        document.getElementById("prevBtn").disabled = false;
      }
    }

    function getBoxes(qId) {
      document.getElementById("boxes").innerHTML = "";

      for (let i = 0; i < questions.length; i++) {
        document.getElementById(
          "boxes"
        ).innerHTML += `<button onclick="boxBtnClick(${i + 1
          }, ${qId})" class="square" id="${i + 1}">${i + 1}</button>`;

        if (!arr[i] == "") {
          document.getElementById(i + 1)?.classList.add("filled-square");
          fillBoxOnOptionSelect(qId);
        }
      }
    }

    function boxBtnClick(btnId, qId) {
      // qId++;
      counter = qId;

      if (questions[counter]["questionType"] == "Subjective") {
        // console.log("btn");

        arr[counter] = document.getElementById("studentAns").value;
      } else {
        if (
          document
            .getElementById("answerOptions")
            .querySelector('input[name="answerOption"]:checked')
        ) {
          arr[counter] = document
            .getElementById("answerOptions")
            .querySelector('input[name="answerOption"]:checked').value;
        } else {
          arr[counter] = "";
        }
      }

      counter = btnId - 1;
      qId = btnId - 1;
      showQuestionAndOptions(counter);
      getBoxes(qId);
      checkForDisablingButton();

      if (questions[counter]["questionType"] == "Subjective") {
        document.getElementById("studentAns").value = arr[counter];
      } else if (arr[counter] != "") {
        document.getElementById(arr[counter]).checked = true;
      }
    }

    function fillBoxOnOptionSelect(qId) {
      document.querySelectorAll('[type="radio"]').forEach((option) => {
        option.addEventListener("change", () => {
          document.getElementById(qId + 1).classList.add("filled-square");
          arr[qId] = option.value;
          // document.getElementById("attendedQuestions").innerHTML =
          //   parseInt(document.getElementById("attendedQuestions").innerHTML) +
          //   1;
          updateAttendedQuestionsCount();
        });
      });
    }

    function updateAttendedQuestionsCount() {
      const attendedCount = arr.filter((answer) => answer !== "").length;
      document.getElementById("attendedQuestions").innerHTML = attendedCount;
    }

    let isSubmitted = false;
    // Replace your submitBtnClicked function with this version
    async function submitBtnClicked() {
      try {
        if (isSubmitted) {
          // console.log("Exam already submitted");
          return;
        }

        if (questions[counter]["questionType"] == "Subjective") {
          arr[counter] = document.getElementById("studentAns").value;
        } else {
          if (
            document
              .getElementById("answerOptions")
              .querySelector('input[name="answerOption"]:checked')
          ) {
            arr[counter] = document
              .getElementById("answerOptions")
              .querySelector('input[name="answerOption"]:checked').value;
          } else {
            arr[counter] = "";
          }
        }

        let questionIds = [];
        for (let i = 0; i < questions.length; i++) {
          questionIds.push(questions[i]["questionId"]);
        }

        let examId = "<%= examId %>";

        if (confirm("Are you sure you want to submit?")) {
          isSubmitted = true; // Set the flag to prevent further submissions

          // Stop screen recording if active
          // if (recordingOngoing) {
          await stopScreenRecording();
          // }

          clearInterval(time);

          // Disable all buttons to prevent further interactions
          document.getElementById("prevBtn").disabled = true;
          document.getElementById("nextBtn").disabled = true;
          document.getElementById("submitBtn").disabled = true;

          let result = await fetch("/api/start-exam/student-answers", {
            method: "post",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              studentAnswers: arr,
              examId: examId,
              questionIds: questionIds,
            }),
          });

          let response = await result.json();
          // console.log("response: ", response);

          if (response.success) {
            alert(response.message);
            location.href = "/student/manageExam";
          } else {
            alert("Something went wrong. Please try again.");
            isSubmitted = false; // Reset the flag if submission failed
          }
        }
      } catch (err) {
        // console.log("error in submitBtnClicked");
        console.log(err);
        isSubmitted = false; // Reset the flag if an error occurred
      }
    }

    async function exitExam() {
      try {
        if (questions[counter]["questionType"] == "Subjective") {
          arr[counter] = document.getElementById("studentAns").value;
        } else {
          if (
            document
              .getElementById("answerOptions")
              .querySelector('input[name="answerOption"]:checked')
          ) {
            arr[counter] = document
              .getElementById("answerOptions")
              .querySelector('input[name="answerOption"]:checked').value;
          } else {
            arr[counter] = "";
          }
        }

        let questionIds = [];

        for (let i = 0; i < questions.length; i++) {
          questionIds.push(questions[i]["questionId"]);
        }

        let examId = "<%= examId %>";

        await stopScreenRecording();
        clearInterval(time);
        let result = await fetch("/api/start-exam/student-answers", {
          method: "post",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            studentAnswers: arr,
            examId: examId,
            questionIds: questionIds,
          }),
        });

        let response = await result.json();
        // console.log("response: ", response);

        if (response.success) {
          // alert(response.message);
          location.href = "/student/manageExam";
        } else {
          alert("Something went wrong please try again!!");
        }
        // }
      } catch (err) {
        // console.log("error in exitExam");
        console.log(err);
      }
    }

    // timer logic starts
    let time;
    function startTimer(duration, display) {
      let start = Date.now(),
        diff,
        minutes,
        seconds;

      async function timer() {
        try {
          // get the number of seconds that have elapsed since
          // startTimer() was called
          diff = duration - (((Date.now() - start) / 1000) | 0);

          // does the same job as parseInt truncates the float
          minutes = (diff / 60) | 0;
          seconds = diff % 60 | 0;

          minutes = minutes < 10 ? "0" + minutes : minutes;
          seconds = seconds < 10 ? "0" + seconds : seconds;

          display.textContent = minutes + ":" + seconds;

          if (diff < 0) {
            start = Date.now() + 1000;
          }

          if (minutes == 0 && seconds == 0) {
            if (isSubmitted) {
              // console.log("Exam already submitted");
              return;
            }
            isSubmitted = true;
            clearInterval(time);
            alert("time over");
            let questionIds = [];

            for (let i = 0; i < questions.length; i++) {
              questionIds.push(questions[i]["questionId"]);
            }

            if (minutes == 0 && seconds == 0) {
              clearInterval(time);
              alert("time over");
              let questionIds = [];

              for (let i = 0; i < questions.length; i++) {
                questionIds.push(questions[i]["questionId"]);
              }

              let examId = "<%= examId %>";

              let result = await fetch("/api/start-exam/student-answers", {
                method: "post",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({
                  studentAnswers: arr,
                  examId: examId,
                  questionIds: questionIds,
                }),
              });

              let response = await result.json();

              if (response.success) {
                alert(response.message);
                location.href = "/student/manageExam";
              } else {
                alert("Something went wrong please try again!!");
                isSubmitted = false;
              }
            }
          }
        } catch (error) {
          throw new Error(error);
        }
      }
      timer();
      time = setInterval(timer, 1000);
    }

    window.addEventListener("keydown", (e) => {
      if (e.keyCode == 27 || e.keyCode == 122) {
        e.preventDefault();
      }
    });

    let interval;
    let fullScreenOffCount = 0;
    // document.addEventListener("fullscreenchange", () => {
    //   if (!document.fullscreenElement) {
    //     fullScreenOffCount++;
    //     console.log("fullScreenOffCount: ", fullScreenOffCount);
    //     if (browserTabChangeCount > 0) {
    //       exitExam();
    //     }

    //     window.onblur = (e) => {
    //       exitExam();
    //     };

    //     interval = setInterval(() => {
    //       if (oldX != window.screenX || oldY != window.screenY) {
    //         console.log("Window screen size changes!");

    //         exitExam();
    //       }

    //       oldX = window.screenX;
    //       oldY = window.screenY;
    //     }, 500);
    //   } else if (document.fullscreenElement) {
    //     stream.addEventListener;

    //     interval = setInterval(() => {
    //       // if (oldX != window.screenX || oldY != window.screenY) {
    //       //   console.log("Window screen size changes!");

    //       //   // exitExam();
    //       // }
    //       if (oldX == window.screenX || oldY == window.screenY) {
    //         return;
    //       }

    //       oldX = window.screenX;
    //       oldY = window.screenY;
    //     }, 500);
    //   } else {
    //     clearInterval(interval);
    //   }
    // });

    let browserTabChangeCount = 0;
    document.addEventListener("visibilitychange", (e) => {
      if (document.hidden) {
        browserTabChangeCount++;
        console.log("browserTabChangeCount: ", browserTabChangeCount);
        exitExam();
      } else {
        if (browserTabChangeCount > 0 || fullScreenOffCount > 3) {
          exitExam();
        }
      }
    });

    window.addEventListener("DOMContentLoaded", (e) => {
      examSidebarDetails();
    });

    let oldX;
    let oldY;

    window.addEventListener("load", (e) => {
      oldX = window.screenX;
      oldY = window.screenY;

      // console.log(
      //   "connection speed: ",
      //   window.navigator.connection.effectiveType
      // );
    });

    let lastPointerClick = false;

    document.addEventListener("fullscreenchange", () => {
      if (!document.fullscreenElement) {
        fullScreenOffCount++;
        console.log("fullScreenOffCount: ", fullScreenOffCount);
        if (browserTabChangeCount > 0) {
          exitExam();
        }

        window.onblur = (e) => {
          exitExam();
        };

          interval = setInterval(() => {
            if (oldX != window.screenX || oldY != window.screenY) {
              // console.log("Window screen size changes!");

            exitExam();
          }

          oldX = window.screenX;
          oldY = window.screenY;
        }, 500);
      } else if (document.fullscreenElement) {
        document.addEventListener("pointerdown", (e) => {
          lastPointerClick = true;
        });

        interval = setInterval(() => {
          if (oldX == window.screenX || oldY == window.screenY) {
            return;
          }

          oldX = window.screenX;
          oldY = window.screenY;
        }, 500);
      } else {
        clearInterval(interval);
      }
    });

    document
      .getElementById("startBtn")
      .addEventListener("click", async () => {
        try {
          window.history.pushState(null, null, window.location.href);
          window.onpopstate = function () {
            window.history.go(1);
          };

          socket.emit("student-join", {
            examId: "<%= examId %>",
            studentId: "<%= studentId %>",
          });

            let examId = "<%= examId %>";
            let result = await fetch("/api/start-exam/start-exam-btn-clicked", {
              method: "post",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({ exam_id: examId }),
            });

          // let response = await result.json();
          // if (response.success) {
          // location.href = `/api/start-exam/instruction/${examId}`;
          // }
          // else{
          //   alert(response.message);
          // }

          const [stream, webCamStream] = await startScreenRecording();
          if (stream == null && webCamStream == null) {
            webCam.pause();
            webCam.src = "";
            webCam.remove();
            return;
          }

          // webCam.addEventListener("loadeddata", async () => {
          //   model = await blazeface.load();

          //   setInterval(detectFaces, 5000);
          // });

          document
            .getElementById("startBtnDiv")
            .classList.remove("startBtnDiv");
          document.getElementById("startBtnDiv").classList.add("hideDiv");
          document
            .getElementById("attendedQuestionsBoxesDiv")
            .classList.remove("hideDiv");
          document
            .getElementById("attendedQuestionsBoxesDiv")
            .classList.add("attendedQuestionsBoxesDiv");
          document
            .getElementById("questionAnswerDiv")
            .classList.remove("hideDiv");
          document
            .getElementById("questionAnswerDiv")
            .classList.add("questionAnswerDiv");

          window.addEventListener("copy", (e) => {
            e.preventDefault();
          });
          window.addEventListener("cut", (e) => {
            e.preventDefault();
          });
          window.addEventListener("paste", (e) => {
            e.preventDefault();
          });
          window.addEventListener("contextmenu", (e) => {
            e.preventDefault();
          });
          window.addEventListener("keyup", (e) => {
            if (e.keyCode == 27 || e.keyCode == 122) {
              e.preventDefault();
            } else if (e.ctrlKey && e.key == "p") {
              e.preventDefault();
              e.cancelable = true;
              e.stopImmediatePropagation();
            }
          });
          window.addEventListener("keydown", (e) => {
            const keyCode = e.keyCode ? e.keyCode : e.which;
            if (keyCode == 13 || keyCode == 93) {
              e.preventDefault();
              return false;
            } else if (e.metaKey || e.key === "Meta" || e.key === "OS") {
              e.preventDefault();
            }
          });

          await examSidebarDetails();

          questions = await getQuestions();
          arr = Array(questions.length).fill("");
          console.log(arr);
          console.log(questions);

          document.getElementById("totalQuestions").innerHTML =
            questions.length;

          showQuestionAndOptions(counter);
          checkForDisablingButton();
          getBoxes(qId);
          // fillBoxOnOptionSelect(counter);

          document.getElementById("prevBtn").addEventListener("click", () => {
            if (questions[counter]["questionType"] == "Subjective") {
              arr[counter] = document.getElementById("studentAns").value;
            } else {
              if (
                document
                  .getElementById("answerOptions")
                  .querySelector('input[name="answerOption"]:checked')
              ) {
                arr[counter] = document
                  .getElementById("answerOptions")
                  .querySelector('input[name="answerOption"]:checked').value;
              } else {
                arr[counter] = "";
              }
            }

            counter--;
            showQuestionAndOptions(counter);
            getBoxes(counter);
            checkForDisablingButton();

            if (questions[counter]["questionType"] == "Subjective") {
              document.getElementById("studentAns").value = arr[counter];
            } else if (arr[counter] != "") {
              document.getElementById(arr[counter]).checked = true;
            }

            // fillBoxOnOptionSelect(counter);
          });

          document.getElementById("nextBtn").addEventListener("click", () => {
            console.log("counter: ", counter);

            if (questions[counter]["questionType"] == "Subjective") {
              arr[counter] = document.getElementById("studentAns").value;
            } else {
              if (
                document
                  .getElementById("answerOptions")
                  .querySelector('input[name="answerOption"]:checked')
              ) {
                arr[counter] = document
                  .getElementById("answerOptions")
                  .querySelector('input[name="answerOption"]:checked').value;
              } else {
                arr[counter] = "";
              }
            }

            counter++;
            showQuestionAndOptions(counter);
            getBoxes(counter);
            checkForDisablingButton();

            if (questions[counter]["questionType"] == "Subjective") {
              document.getElementById("studentAns").value = arr[counter];
            } else if (arr[counter] != "") {
              document.getElementById(arr[counter]).checked = true;
            }

            // fillBoxOnOptionSelect(counter);
          });

          document
            .getElementById("submitBtn")
            .addEventListener("click", submitBtnClicked);

          startTimer(60 * examDuration, document.getElementById("timer"));
        } catch (error) {
          throw new Error(error);
        }
      });
  </script>
</body>

</html>